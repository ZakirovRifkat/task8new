quicksort
Массив из 5 элементов[2,6,4,8,7];

1)Вычисляем опорный:p_ind=2 ;piv=4;i=first=0; j=last=n-1=4;

2)Заходим в do while(i <=j);

3)Заходим в while(i!=p_ind и arr[i]<piv)-> 0!=2 и 2<4, т.к i<j (0<4) -> sravn++( кол-во сравнений:1) увеличиваем i; повтор while(i!=p_ind и arr[i]<piv)(неверно,т.к 1!=2,но 6>4)->if(i!=p_ind и I<j) 1!=2 и 1<4 -> sravn++(кол-во сравнений:2);

4)Заходим в while(j!=p_ind и arr[j]>piv) 4!=2 и 7>4->if(i<j) 1<4 ->sravn++( кол-во сравнений:3) уменьшаем j; Повторяем while(j!=p_ind и arr[j]>piv) 3!=2 и 8>4-> if(i<j) 1<3 ->sravn++( кол-во сравнений:4) уменьшаем j; Повторяем while(j!=p_ind и arr[j]>piv)(неверно,т.к 2=2 и 4>4)->if(j!=p_ind и i<j)(неверно,т.к 2=2 и 1<2)

5)Заходим в if(i<=j) 1<2->if(i!=j) 1!=2 ->меняем arr[i] и arr[j] -> perest++; Изменённый массив:[2 4 6 8 7]; уменьшаем j и увеличиваем i;

6)while(i<=j)(неверно,т.к 2>1) выходим из do while(i<=j);

7)if(i<last) 2<4 -> quicksort(arr, 2, 4);

8)Вычисляем опорный: p_ind=3 =>piv=8 i=first=2; j=last=4;

9)Заходим в do while(i<=j);

10)Заходим в while(i!=p_ind и arr[i]<piv) 2!=3 и 6<8-> if(i<j) 2<4 -> sravn++( кол-во сравнений:5) увеличиваем i; повторяем while(i!=p_ind и arr[i]<piv)(неверно,т.к 3=3 и 8<8) -> if(i!=p_ind и i<j)(неверно 3=3); Заходим в while(j!=p_ind и arr[j]>piv)(неверно,т.к 4!=3, но 7<8) -> if(j!=p_ind и i<j) 4!=3 и 3<4 -> sravn++( Кол-во сравнений: 6);

11)Заходим в if(i<=j) 3<=4 -> if(i!=j) 3!=4 -> меняем arr[i] и arr[j] => perest++ (кол-во перест:2);

12)Изменённый массив:[2 4 6 7 8]; уменьшаем j и увеличиваем i;

13)while(i<=j) (неверно,т.к 4<=3)-> Выходим из do while(i<=j);

14)if(i<last)(неверно,т.к 4=4)-> if(j>first) 3>2 вызываем quicksort(arr, 2,3);

15)Вычисляем опорный: p_ind=2 =>piv=6 i=first=2; j=last=3;

16)Заходим в do while(i <=j) 2<3;

17)Заходим в while(i!=p_ind и arr[i]<piv) (неверно 2=2 6=6)-> if(i!=p_ind и i<j)(неверно 2=2);

18)Заходим в while(j!=p_ind и arr[j]>piv) 3!=2, 7>6 -> if(i<j) 2<3 -> sravn++ (кол-во сравнений 7), уменьшаем j; if(j!=p_ind и arr[j]>piv)(неверно,т.к 2=2 6=6) -> if(j!=p_ind и i<j)(неверно,т.к 2=2) -> if(i<=j) 2=2 i=j массив не трогаем. увеличиваем i, уменьшаем j;

19)while(i<=j) 3>1 выходим из do while;

20)if(i<last)(неверно 3=3);

21)if(j>first)(Нет 1<2)->значит возвращаемся к первому рекурсивному вызову и вызываем quicksort(arr, 0,1)( т.к j>first (1>0);

Вычисляем опорный: p_ind=0=> piv=2 I=first=0; j=last=1;
23)Заходим в do while(i <=j) 0<1;

24)Заходим в while(i!=p_ind и arr[i]<piv)(неверно,т.к 0=0 2=2) -> if(i!=p_ind и i<j) (неверно,т.к 0=0);

25)Заходим в while(j!=p_ind и arr[j]>piv) 1!=0 и 4>2 -> if(i<j) 0<1-> sravn++ (кол-во сравнений 8), уменьшаем j; while(j!=p_ind и arr[j]>piv)(неверно,т.к 0=0)->if(j!=p_ind и i<j)(неверно,т.к 0=0) -> if(i<=j) 0=0 т.к I=j массив не трогаем, увеличиваем I, уменьшаем j;

26)while(i<=j)(неверно,т.к 1>-1) -> выходим из do while;

27)if(i<last) Нет 1=1 -> if(j >first) Нет -1<0 -> рекурсивно ничего не вызываем ->

Отсортированный массив[2,4,6,7,8] Перестановок:2 Сравнений:8
